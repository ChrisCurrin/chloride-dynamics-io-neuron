# coding=utf-8
import os
import shutil
import logging
from pathlib import Path
from datetime import datetime
from typing import List, Union

import pandas as pd

logger = logging.getLogger("file_io")


def create_dir(root: str, timestamp: bool = True) -> str:
    """
    Create pull directory path with an optional timestamp.
    :param root: Directory path
    :param timestamp: Include a timestamp for the created directory (default True)
    :return: path of created directory
    """
    if timestamp:
        date = "_" + datetime.strftime(datetime.now(), '%Y_%m_%d_%Hh%M')
    else:
        date = ""
    path = root + date
    try:
        os.makedirs(path)
    except OSError:
        if not os.path.isdir(path):
            raise
    return path


def copy_file(src, dest):
    """Fault-tolerant copying of files from src to dest
     From shutil docs:
       If dest is a directory, a file with the same basename as
       src is created (or overwritten) in the directory specified.
    """

    try:
        shutil.copy(src, dest)
    except shutil.Error as e:
        # eg. src and dest are the same file
        print('Error: %s'%e)
    except IOError as e:
        # eg. source or destination doesn't exist
        print('Error: %s'%e.strerror)


def move_file(src, dest):
    """Fault-tolerant moving of files from src to dest
    """
    try:
        copy_file(src, dest)
        os.remove(src)
    except IOError or shutil.Error:
        print("error copying file")

def delete_files(paths: Union[str, Path, List[Union[str, Path]]]):
    """Delete the files in the list of paths."""
    if isinstance(paths, str):
        paths = [paths]
    elif isinstance(paths, Path):
        paths = [paths]

    for path in paths:
        if isinstance(path, str):
            path = Path(path)
        if path.exists():
            path.unlink(missing_ok=True)


class cd(object):
    """Context manager for changing the current working directory"""

    def __init__(self, new_path, with_logs=True):
        self.new_path = os.path.expanduser(new_path)
        self.with_logs = with_logs

    def __enter__(self):
        self.savedPath = os.getcwd()
        os.chdir(self.new_path)
        if self.with_logs:
            logger.info("in " + self.new_path)

    def __exit__(self, etype, value, traceback):
        os.chdir(self.savedPath)
        if self.with_logs:
            logger.info("out " + self.new_path)
            logger.info("in " + self.savedPath)


def read_ei_file(file: str) -> dict:
    """put values from file into a dict of
       {
        (exc weight,inh weight):
           {
                  (exc synapses,inh synapses): (spikes, stddev, samples),
                  (exc synapses,inh synapses): (spikes, stddev, samples)
           },
        (exc weight, inh weight):
           ...
       }
    """
    spikes = dict()
    with open(file, 'r') as f:
        check_num = (0, 0)
        constant_num_old = None  # these are values which should be constant for a run
        ei_strength = dict()
        for line in f:
            if line[0:3] == "exc":
                # line ~= exc_syn: 398 (1)	 inh_syn: 21 (1)
                split_line = line.split()  # default separate on spaces
                # number of synapses (exc, inh)
                check_num = (int(split_line[1]), int(split_line[4]))
                # weight of synapses (exc, inh)
                constant_num = (
                    int(split_line[2][1:-1]), int(split_line[5][1:-1])  # [1:-1] to remove parentheses
                    )

                if constant_num != constant_num_old and spikes.items() != []:
                    if constant_num_old is None:
                        constant_num_old = constant_num
                    else:
                        ei_strength[constant_num_old] = spikes.copy()  # associate the values not the reference
                        spikes = dict()
                        constant_num_old = constant_num
            elif line.find("+-") > 0:
                # line ~= 14.0 +- 0.0 (n=1)
                split_line = line.split()
                spike = float(split_line[0])
                stddev = float(split_line[2])
                n = float(split_line[3][3:-1])  # truncate (n=
                spikes[check_num] = (spike, stddev, n)  # spikes[(exc strength,inh strength)]
    ei_strength[constant_num_old] = spikes.copy()  # associate the values not the reference
    logger.debug(f"ei_strength={ei_strength}")
    return ei_strength


def read_hoc_output(glob_object: List[str]) -> pd.DataFrame:
    """ Convert data from `hoc_output<date>.txt` - file generated by `protocols.run_protocol` - to a pandas dataframe

    Example output from file


        inhibit: 45  	->   spikes    EDend 	 spikes (soma) 	 Soma EGABA 	 ldend EGABA 	 bdend EGABA
             excite: 45
                            ->     74		 -14.89   	 0   		  -77.40  		  -77.40  		  -77.40
                            ->     74		 -14.30   	 0   		  -77.40  		  -77.40  		  -77.40
                            ->     75		 -13.98   	 0   		  -77.40  		  -77.40  		  -77.40
                mean: 		->     74		 -14.39   	 0   		  -77.40  		  -77.40  		  -77.40
            excite: 50
                            ->     76		 -14.89   	 0   		  -77.40  		  -77.40  		  -77.40
                            ->     78		 -14.30   	 0   		  -77.40  		  -77.40  		  -77.40
                            ->     77		 -13.98   	 0   		  -77.40  		  -77.40  		  -77.40
                mean: 		->     77		 -14.39   	 0   		  -77.40  		  -77.40  		  -77.40
        saving...
        saved to pyramidal_260,30_InPt00000045_noise(1,1)_weights(1,1).dat
    """
    df = pd.DataFrame(columns=["E (Synapses)", "I (Synapses)", "E (Hz)", "I (Hz)", "Firing Rate (Hz)", "KCC2"])
    for file_name in glob_object:
        logger.debug(f"opening {file_name}")
        with open(file_name) as f:
            sim = -1
            data = {}
            for line in f.readlines():
                if len(line) > 5:
                    if 'inhibit:' in line:
                        sim += 1
                        inh = int(line[line.index(':') + 1:line.index('->')])
                        # new data object
                        data = {'I (Hz)': inh}
                        exc_dict = {}
                        logger.debug(f"inhibition = {inh}")
                    elif sim >= 0 and 'excite:' in line:
                        exc = int(line[line.index(':') + 1:])
                        exc_dict[exc] = []
                    elif '->' in line and 'mean' not in line:
                        entries = [l.strip() for l in line.split('\t') if l]
                        fr = float(entries[0].split()[-1])  # first entry is '-->   <spikes>'
                        exc_dict[exc].append(fr)
                    elif 'saved' in line:
                        saved_file_name = line.split()[-1]
                        if 'KCC2' in saved_file_name:
                            data['KCC2'] = True
                            saved_file_name = saved_file_name.replace('_KCC2', '')
                        else:
                            data['KCC2'] = False
                        props = saved_file_name.split('_')

                        nrn_type, num_syn, inhpt, noise, weights = props
                        e_syn, i_syn = [int(n) for n in num_syn.split(',')]
                        data['E (Synapses)'] = e_syn
                        data['I (Synapses)'] = i_syn
                        # assign data for this simulation to the dataframe
                        for exc, fr_arr in exc_dict.items():
                            logger.debug(f"\texcitation = {exc}")
                            data['E (Hz)'] = exc
                            for fr in fr_arr:
                                # reassign for each trial (everything else being equal)
                                data['Firing Rate (Hz)'] = fr
                                # always add to end
                                df.loc[df.shape[0]] = data
                        logger.debug(f"e_syn = {e_syn} i_syn = {i_syn} loaded")
    logger.debug(f"loaded DataFrame. df.shape = {df.shape}")
    return df
